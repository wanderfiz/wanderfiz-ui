import { renderHook, act } from '@testing-library/react'
import { useResponsive, useMediaQuery, useBreakpointValue, useOrientation, useTouch } from '../useResponsive'

// Mock window object for tests
const addEventListenerSpy = jest.spyOn(window, 'addEventListener')
const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener')

Object.defineProperty(window, 'innerWidth', {
  writable: true,
  configurable: true,
  value: 1024,
})

Object.defineProperty(window, 'innerHeight', {
  writable: true,
  configurable: true,
  value: 768,
})

Object.defineProperty(navigator, 'maxTouchPoints', {
  writable: true,
  configurable: true,
  value: 0,
})

describe('useResponsive Hook', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    addEventListenerSpy.mockClear()
    removeEventListenerSpy.mockClear()
    window.innerWidth = 1024
    window.innerHeight = 768
  })

  describe('useResponsive', () => {
    it('returns correct initial values for desktop screen', () => {
      const { result } = renderHook(() => useResponsive())

      expect(result.current.screenWidth).toBe(1024)
      expect(result.current.screenHeight).toBe(768)
      expect(result.current.isMobile).toBe(false)
      expect(result.current.isTablet).toBe(false)
      expect(result.current.isDesktop).toBe(true)
      expect(result.current.isLargeDesktop).toBe(false)
      expect(result.current.currentBreakpoint).toBe('lg')
    })

    it('correctly identifies mobile screen', () => {
      window.innerWidth = 640
      const { result } = renderHook(() => useResponsive())

      expect(result.current.isMobile).toBe(true)
      expect(result.current.isTablet).toBe(false)
      expect(result.current.isDesktop).toBe(false)
      expect(result.current.isLargeDesktop).toBe(false)
      expect(result.current.currentBreakpoint).toBe('sm')
    })

    it('correctly identifies tablet screen', () => {
      window.innerWidth = 800
      const { result } = renderHook(() => useResponsive())

      expect(result.current.isMobile).toBe(false)
      expect(result.current.isTablet).toBe(true)
      expect(result.current.isDesktop).toBe(false)
      expect(result.current.isLargeDesktop).toBe(false)
      expect(result.current.currentBreakpoint).toBe('md')
    })

    it('correctly identifies large desktop screen', () => {
      window.innerWidth = 1600
      const { result } = renderHook(() => useResponsive())

      expect(result.current.isMobile).toBe(false)
      expect(result.current.isTablet).toBe(false)
      expect(result.current.isDesktop).toBe(false)
      expect(result.current.isLargeDesktop).toBe(true)
      expect(result.current.currentBreakpoint).toBe('2xl')
    })

    it('correctly identifies xl breakpoint', () => {
      window.innerWidth = 1280
      const { result } = renderHook(() => useResponsive())

      expect(result.current.currentBreakpoint).toBe('xl')
    })

    it('updates values when window is resized', () => {
      let resizeHandler: () => void = () => {}
      
      window.addEventListener = jest.fn((event, handler) => {
        if (event === 'resize') {
          resizeHandler = handler as () => void
        }
      })

      const { result } = renderHook(() => useResponsive())

      // Initial desktop state
      expect(result.current.isMobile).toBe(false)
      expect(result.current.currentBreakpoint).toBe('lg')

      // Simulate resize to mobile
      act(() => {
        window.innerWidth = 640
        window.innerHeight = 480
        resizeHandler()
      })

      expect(result.current.screenWidth).toBe(640)
      expect(result.current.screenHeight).toBe(480)
      expect(result.current.isMobile).toBe(true)
      expect(result.current.currentBreakpoint).toBe('sm')
    })

    it('adds and removes resize event listener', () => {
      const { unmount } = renderHook(() => useResponsive())

      expect(window.addEventListener).toHaveBeenCalledWith('resize', expect.any(Function))

      unmount()

      expect(window.removeEventListener).toHaveBeenCalledWith('resize', expect.any(Function))
    })

    it('handles undefined window object', () => {
      const originalWindow = global.window
      // @ts-ignore
      delete global.window

      const { result } = renderHook(() => useResponsive())

      expect(result.current.screenWidth).toBe(0)
      expect(result.current.screenHeight).toBe(0)

      global.window = originalWindow
    })
  })

  describe('useMediaQuery', () => {
    it('returns true when media query matches', () => {
      const mockMediaQuery = {
        matches: true,
        addEventListener: jest.fn(),
        removeEventListener: jest.fn()
      }

      window.matchMedia = jest.fn().mockReturnValue(mockMediaQuery)

      const { result } = renderHook(() => useMediaQuery('(min-width: 768px)'))

      expect(result.current).toBe(true)
      expect(window.matchMedia).toHaveBeenCalledWith('(min-width: 768px)')
    })

    it('returns false when media query does not match', () => {
      const mockMediaQuery = {
        matches: false,
        addEventListener: jest.fn(),
        removeEventListener: jest.fn()
      }

      window.matchMedia = jest.fn().mockReturnValue(mockMediaQuery)

      const { result } = renderHook(() => useMediaQuery('(min-width: 768px)'))

      expect(result.current).toBe(false)
    })

    it('updates when media query changes', () => {
      let changeHandler: (event: MediaQueryListEvent) => void = () => {}
      const mockMediaQuery = {
        matches: false,
        addEventListener: jest.fn((event, handler) => {
          if (event === 'change') {
            changeHandler = handler
          }
        }),
        removeEventListener: jest.fn()
      }

      window.matchMedia = jest.fn().mockReturnValue(mockMediaQuery)

      const { result } = renderHook(() => useMediaQuery('(min-width: 768px)'))

      expect(result.current).toBe(false)

      // Simulate media query change
      act(() => {
        changeHandler({ matches: true } as MediaQueryListEvent)
      })

      expect(result.current).toBe(true)
    })

    it('cleans up event listener on unmount', () => {
      const mockMediaQuery = {
        matches: false,
        addEventListener: jest.fn(),
        removeEventListener: jest.fn()
      }

      window.matchMedia = jest.fn().mockReturnValue(mockMediaQuery)

      const { unmount } = renderHook(() => useMediaQuery('(min-width: 768px)'))

      unmount()

      expect(mockMediaQuery.removeEventListener).toHaveBeenCalledWith('change', expect.any(Function))
    })

    it('handles undefined window', () => {
      const originalWindow = global.window
      // @ts-ignore
      delete global.window

      const { result } = renderHook(() => useMediaQuery('(min-width: 768px)'))

      expect(result.current).toBe(false)

      global.window = originalWindow
    })
  })

  describe('useBreakpointValue', () => {
    it('returns correct value for current breakpoint', () => {
      window.innerWidth = 1024 // lg breakpoint

      const values = {
        sm: 'small',
        md: 'medium',
        lg: 'large',
        xl: 'extra-large'
      }

      const { result } = renderHook(() => useBreakpointValue(values))

      expect(result.current).toBe('large')
    })

    it('falls back to smaller breakpoint when current is not defined', () => {
      window.innerWidth = 1024 // lg breakpoint

      const values = {
        sm: 'small',
        md: 'medium'
        // lg not defined, should fall back to md
      }

      const { result } = renderHook(() => useBreakpointValue(values))

      expect(result.current).toBe('medium')
    })

    it('returns undefined when no suitable value is found', () => {
      window.innerWidth = 1024 // lg breakpoint

      const values = {
        xl: 'extra-large',
        '2xl': 'extra-extra-large'
        // no values for current or smaller breakpoints
      }

      const { result } = renderHook(() => useBreakpointValue(values))

      expect(result.current).toBe(undefined)
    })

    it('works with different value types', () => {
      window.innerWidth = 800 // md breakpoint

      const values = {
        sm: 12,
        md: 24,
        lg: 32
      }

      const { result } = renderHook(() => useBreakpointValue(values))

      expect(result.current).toBe(24)
    })
  })

  describe('useOrientation', () => {
    it('returns portrait for taller screens', () => {
      window.innerWidth = 768
      window.innerHeight = 1024

      const { result } = renderHook(() => useOrientation())

      expect(result.current).toBe('portrait')
    })

    it('returns landscape for wider screens', () => {
      window.innerWidth = 1024
      window.innerHeight = 768

      const { result } = renderHook(() => useOrientation())

      expect(result.current).toBe('landscape')
    })

    it('updates orientation on window resize', () => {
      let resizeHandler: () => void = () => {}
      
      window.addEventListener = jest.fn((event, handler) => {
        if (event === 'resize') {
          resizeHandler = handler as () => void
        }
      })

      window.innerWidth = 768
      window.innerHeight = 1024

      const { result } = renderHook(() => useOrientation())

      expect(result.current).toBe('portrait')

      // Simulate rotation to landscape
      act(() => {
        window.innerWidth = 1024
        window.innerHeight = 768
        resizeHandler()
      })

      expect(result.current).toBe('landscape')
    })
  })

  describe('useTouch', () => {
    it('returns true for touch devices with ontouchstart', () => {
      Object.defineProperty(window, 'ontouchstart', {
        value: {},
        configurable: true
      })

      const { result } = renderHook(() => useTouch())

      expect(result.current).toBe(true)
    })

    it('returns true for touch devices with maxTouchPoints', () => {
      delete (window as Record<string, unknown>).ontouchstart
      Object.defineProperty(navigator, 'maxTouchPoints', {
        value: 1,
        configurable: true
      })

      const { result } = renderHook(() => useTouch())

      expect(result.current).toBe(true)
    })

    it('returns false for non-touch devices', () => {
      delete (window as Record<string, unknown>).ontouchstart
      Object.defineProperty(navigator, 'maxTouchPoints', {
        value: 0,
        configurable: true
      })

      const { result } = renderHook(() => useTouch())

      expect(result.current).toBe(false)
    })
  })
})